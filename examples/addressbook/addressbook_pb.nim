# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json

import nimpb/nimpb
import nimpb/json as nimpb_json

import phonenumber_pb

type
    Person* = ref PersonObj
    PersonObj* = object of Message
        name: string
        id: int32
        email: string
        phones: seq[PhoneNumber]
    AddressBook* = ref AddressBookObj
    AddressBookObj* = object of Message
        people: seq[Person]

proc newPerson*(): Person
proc newPerson*(data: string): Person
proc newPerson*(data: seq[byte]): Person
proc writePerson*(stream: Stream, message: Person)
proc readPerson*(stream: Stream): Person
proc sizeOfPerson*(message: Person): uint64
proc toJson*(message: Person): JsonNode

proc newAddressBook*(): AddressBook
proc newAddressBook*(data: string): AddressBook
proc newAddressBook*(data: seq[byte]): AddressBook
proc writeAddressBook*(stream: Stream, message: AddressBook)
proc readAddressBook*(stream: Stream): AddressBook
proc sizeOfAddressBook*(message: AddressBook): uint64
proc toJson*(message: AddressBook): JsonNode

proc newPerson*(): Person =
    new(result)
    initMessage(result[])
    result.name = ""
    result.id = 0
    result.email = ""
    result.phones = @[]

proc clearname*(message: Person) =
    message.name = ""
    clearFields(message, [1])

proc hasname*(message: Person): bool =
    result = hasField(message, 1)

proc setname*(message: Person, value: string) =
    message.name = value
    setField(message, 1)

proc name*(message: Person): string {.inline.} =
    message.name

proc `name=`*(message: Person, value: string) {.inline.} =
    setname(message, value)

proc clearid*(message: Person) =
    message.id = 0
    clearFields(message, [2])

proc hasid*(message: Person): bool =
    result = hasField(message, 2)

proc setid*(message: Person, value: int32) =
    message.id = value
    setField(message, 2)

proc id*(message: Person): int32 {.inline.} =
    message.id

proc `id=`*(message: Person, value: int32) {.inline.} =
    setid(message, value)

proc clearemail*(message: Person) =
    message.email = ""
    clearFields(message, [3])

proc hasemail*(message: Person): bool =
    result = hasField(message, 3)

proc setemail*(message: Person, value: string) =
    message.email = value
    setField(message, 3)

proc email*(message: Person): string {.inline.} =
    message.email

proc `email=`*(message: Person, value: string) {.inline.} =
    setemail(message, value)

proc clearphones*(message: Person) =
    message.phones = @[]
    clearFields(message, [4])

proc hasphones*(message: Person): bool =
    result = hasField(message, 4) or (len(message.phones) > 0)

proc setphones*(message: Person, value: seq[PhoneNumber]) =
    message.phones = value
    setField(message, 4)

proc addphones*(message: Person, value: PhoneNumber) =
    add(message.phones, value)
    setField(message, 4)

proc phones*(message: Person): seq[PhoneNumber] {.inline.} =
    message.phones

proc `phones=`*(message: Person, value: seq[PhoneNumber]) {.inline.} =
    setphones(message, value)

proc sizeOfPerson*(message: Person): uint64 =
    if hasname(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    if hasid(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.id)
    if hasemail(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfString(message.email)
    for value in message.phones:
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPhoneNumber(value))
    result = result + sizeOfUnknownFields(message)

proc writePerson*(stream: Stream, message: Person) =
    if hasname(message):
        protoWriteString(stream, message.name, 1)
    if hasid(message):
        protoWriteInt32(stream, message.id, 2)
    if hasemail(message):
        protoWriteString(stream, message.email, 3)
    for value in message.phones:
        writeMessage(stream, value, 4)
    writeUnknownFields(stream, message)

proc readPerson*(stream: Stream): Person =
    result = newPerson()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setid(result, protoReadInt32(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            setemail(result, protoReadString(stream))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addphones(result, newPhoneNumber(data))
        else: readUnknownField(stream, result, tag)

proc toJson*(message: Person): JsonNode =
    result = newJObject()
    if hasname(message):
        result["name"] = %message.name
    if hasid(message):
        result["id"] = %message.id
    if hasemail(message):
        result["email"] = %message.email
    if hasphones(message):
        let arr = newJArray()
        for value in message.phones:
            add(arr, toJson(value))
        result["phones"] = arr

proc serialize*(message: Person): string =
    let
        ss = newStringStream()
    writePerson(ss, message)
    result = ss.data

proc newPerson*(data: string): Person =
    let
        ss = newStringStream(data)
    result = readPerson(ss)

proc newPerson*(data: seq[byte]): Person =
    let
        ss = newStringStream(cast[string](data))
    result = readPerson(ss)


proc newAddressBook*(): AddressBook =
    new(result)
    initMessage(result[])
    result.people = @[]

proc clearpeople*(message: AddressBook) =
    message.people = @[]
    clearFields(message, [1])

proc haspeople*(message: AddressBook): bool =
    result = hasField(message, 1) or (len(message.people) > 0)

proc setpeople*(message: AddressBook, value: seq[Person]) =
    message.people = value
    setField(message, 1)

proc addpeople*(message: AddressBook, value: Person) =
    add(message.people, value)
    setField(message, 1)

proc people*(message: AddressBook): seq[Person] {.inline.} =
    message.people

proc `people=`*(message: AddressBook, value: seq[Person]) {.inline.} =
    setpeople(message, value)

proc sizeOfAddressBook*(message: AddressBook): uint64 =
    for value in message.people:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPerson(value))
    result = result + sizeOfUnknownFields(message)

proc writeAddressBook*(stream: Stream, message: AddressBook) =
    for value in message.people:
        writeMessage(stream, value, 1)
    writeUnknownFields(stream, message)

proc readAddressBook*(stream: Stream): AddressBook =
    result = newAddressBook()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addpeople(result, newPerson(data))
        else: readUnknownField(stream, result, tag)

proc toJson*(message: AddressBook): JsonNode =
    result = newJObject()
    if haspeople(message):
        let arr = newJArray()
        for value in message.people:
            add(arr, toJson(value))
        result["people"] = arr

proc serialize*(message: AddressBook): string =
    let
        ss = newStringStream()
    writeAddressBook(ss, message)
    result = ss.data

proc newAddressBook*(data: string): AddressBook =
    let
        ss = newStringStream(data)
    result = readAddressBook(ss)

proc newAddressBook*(data: seq[byte]): AddressBook =
    let
        ss = newStringStream(cast[string](data))
    result = readAddressBook(ss)


